package main

import "fmt"

var p = func(s interface{}) {
	fmt.Printf("%#v\n", s)
}

/*
配列は宣言しただけで値が初期化される。
スライスは宣言しただけでは型は決まっていても内部がnilになっている。
これはスライスが参照型だから。nilは何も参照していないことを表す。

makeを実行して初めて型の初期値で内部が初期化される。
sliceの容量以上の要素を格納しようとすると、スライス全体を別のメモリ空間にコピーして、要素を追加する。
この処理は重い。可能であれば、スライスの容量を指定した方がパフォーマンスはよくなる。
リテラルでもスライスを作ることはできる。
スライスと配列のリテラルでの生成は似ていて、スライスは要素の宣言がない。
配列とスライスはお互いに代入することはできない。
簡易スライス式では指定した要素のスライスをコピーした新しいスライスを生成できる。
簡易スライス式は文字列に対しても使える。

 */
func main() {
	// スライス
	var slice []int
	p(slice) // []int(nil)
	slice = make([]int, 10)
	p(slice) // []int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

	// 配列
	var array [10]int
	p(array) // [10]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

	p(array[9])
	p(slice[9])

	// ランタイムパニック
	// p(slice[10]) // index out of range

	p(len(slice)) // 現在の長さ


	// 要素数5、容量10のスライス
	slice2 := make([]int, 5, 10)
	p(slice2)
	p(len(slice2))
	p(cap(slice2))


	// リテラルで生成する
	// 配列の要素数を指定しないとスライスになる。
	p("リテラルでの生成==================================================================================")
	slice3 := []int{1,2,3}
	array3 := [3]int{1,2,3}
	p(slice3)
	p(array3)

	// スライスは要素を追加できる。
	p("要素の追加==================================================================================")
	slice3 = append(slice3, 4)
	p(slice3)

	// 配列は固定長のため要素の追加ができない。
	//array3 = append(array3, 4) // first argument to append must be slice; have [3]int

	// 簡易スライス式
	p("簡易スライス式==================================================================================")
	slice4 := slice3[0:2] // slice3の0から2要素目までコピーした新スライスを作る。
	p(slice4) // 1,2

	// 配列にスライスを代入することはできない。
	//array4 := [3]int{}
	//array4 = slice3[0:2]
	//p(array4)

	// 同様にスライスに配列を代入することもできない。
	//var slice5 []int
	//slice5 = array3
	//p(slice5)

	// slice3 = []int{1,2,3,4}
	p(slice3[2:]) // 2要素目から最後の要素までをコピー  3,4
	p(slice3[:2]) // 0要素目から2要素目までをコピー 1,2
	p(slice3[:]) // 全ての要素をコピー 1,2,3,4
	p(slice3[:len(slice3) -1]) // 配列の要素数 - 1個の要素を0番目からコピー 1,2,3

	// 文字に対しても簡易スライス式が使える。
	p("ABCDE"[0:2]) // AB

}
