package main

import (
	"time"
	"fmt"
)

// ゴルーチンをmake関数でバッファサイズを指定せずに生成すると、
// バッファサイズゼロのゴルーチンができる

/*
 # チャネル
 ## 目的
 ゴルーチン間で値を受け渡すためのキュー。
 デフォルトでチャネル内に格納できる値の数は１つ。

 # バッファ
 チャネルを生成するときにバッファサイズを指定できる。
 バッファを指定しない場合、バッファサイズがゼロのチャネルができ、チャネル内に格納できる値の数は１つ。

 バッファはあくまで、チャネルの追加の送受信領域であって、チャネル全体のキューのサイズを示すものではない。
 バッファがゼロのチャネルは送受信できる領域が1つ。（デフォルト領域:1 + バッファ:0）
 バッファが1のチャネルは送受信できる領域が2つ（デフォルト領域:1 + バッファ:1)

 ## 送信側への影響
 チャネルに値を送信したあと、
 バッファを含め、チャネル全体の格納領域に空きがある場合、送信後、次の処理に移れる。
 空きがない場合、送信処理の行で、受信されるまで待つことになる。

 ## チャネル内のデータの有無
 len関数をチャネル型の変数に適用した場合、戻り値として得られるのは、バッファ内の値の件数。
 チャネル内全体の件数ではない。
 チャネル内全体の件数は、lenで取得した件数が1以上であれば、
 チャネルのデフォルトで格納できる1件 + lenで取得した件数で計算できる。
 lenが0を返す場合、かつチャネルのバッファがゼロの場合、
 チャネルに値が入っているかどうかlenの結果からでは判断がつかない。

 ## チャネルのキューとしての機能
 チャネルはゴルーチン間の値の受け渡しに利用するために設計されている。
 単独のmain関数から起動されたゴルーチン内のみでキューのように利用してはならない。

 バッファが1以上あれば、自分で他のゴルーチンを起動していなくても、
 チャネルに値を送信して、そのチャネルから送信した値を受信することは確かにできるが、
 ゴルーチンはそのような一つのゴルーチン内で利用するキューのような目的で設計されたものではない。
 バッファの空きがなくなり、デッドロックに陥る可能性があり危険。
 チャネルはゴルーチン間の値の受け渡しのみに利用する。

 */

func main() {
	ch := make(chan int64)

	go sender(ch)

	for {
		time.Sleep(1 * time.Second)
		fmt.Printf("current buffering size %d\n", len(ch))
		// fmt.Printf("received %d\n", <-ch)
	}
}



func sender(ch chan int64) {
	for {
		time.Sleep(1 * time.Second)
		var value = time.Now().Unix()
		fmt.Printf("send befer %d\n", value)
		ch <- value  // バッファに空きがない状態では送ったあと、受信されるまで次の処理に進まない。
		fmt.Printf("send after %d\n")
	}
}
