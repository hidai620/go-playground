package main

import "fmt"

var p = func(s interface{}) {
	fmt.Printf("%#v\n", s)
}

/*
配列の初期値を指定しなかった要素には、その肩の初期値が適用される。
ドットにすると配列の初期値で指定した要素数の配列として定義される。
配列は同じ要素数の配列にしか代入できない。
配列の代入はコピー。値を代入された配列は、要素の値を変更しても、代入元には影響しない。
配列の拡張はできない。
 */
func main() {
	p([5]int{1,2,3,4,5}) // [5]int{1, 2, 3, 4, 5}
	p([5]int{1,2,3}) //[5]int{1, 2, 3, 0, 0}

	// 中括弧をつけてもつけなくても結果は同じ
	p([5]int{}) // [5]int{0, 0, 0, 0, 0}

	var array [5]int
	p(array) // [5]int{0, 0, 0, 0, 0}


	// 初期値を指定しない場合、その型のゼロを表す値で初期化される
	p([3]bool{}) // false
	p([3]string{}) // ""
	p([3]float32{}) // 0
	p([3]float64{}) // 0
	p([3]complex128{}) // 0+0i
	p([3]rune{}) // 0

	// この二つは同じ
	p([5]int{1,2,3,4,5}) // [5]int{1, 2, 3, 4, 5}
	p([...]int{1,2,3,4,5}) // [5]int{1, 2, 3, 4, 5}

	a := [5]int{1,2,3,4,5}
	a[0] = 10
	// a[1] = float32(10) // コンパイルエラー

	// 要素型の異なる配列の代入はできない。
	//b := [5]uint{1,2,3,4,5}
	//a = b

	//c := [0]int{}
	//c = a // 代入先が代入しようとしている配列と同じ要素でない場合エラー

	//d := [10]int{}
	//d = a // 代入先に代入しようとしている配列以上の要素数でもエラー

	e := [5]int{}
	e = a // 代入先に代入しようとしている配列以上の要素数がない場合エラー
	p(e)

	//代入された値を書き換えても、代入元の配列には影響がない。(値がコピーされる)
	e[0] = 100
	p(a) // 1,2,3,4,5
	p(e) // 100,2,3,4,5
}
